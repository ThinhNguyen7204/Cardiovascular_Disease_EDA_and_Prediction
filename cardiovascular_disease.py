# -*- coding: utf-8 -*-
"""Cardiovascular_Disease.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1egPeRwAzk_EZ4k7XaG3U9E4ZJEHC40FH

Suy tim (heart failure) là một trong những bệnh lý tim mạch nguy hiểm nhất, gây ra hàng
triệu ca tử vong mỗi năm trên toàn cầu và đang trở thành gánh nặng y tế công cộng ngày càng
nghiêm trọng. Theo Tổ chức Y tế Thế giới (WHO), suy tim không chỉ làm giảm chất lượng cuộc
sống mà còn gia tăng đáng kể chi phí điều trị và tỷ lệ tái nhập viện. Việc nhận diện sớm các yếu
tố nguy cơ và dự đoán chính xác khả năng xảy ra suy tim ở từng cá nhân là yếu tố then chốt để
can thiệp kịp thời, giảm thiểu biến chứng và cải thiện tiên lượng bệnh.

Trong nghiên cứu này, nhóm đã sử dụng tập dữ liệu cardio_train.csv – một bộ dữ liệu lớn
với 70.000 bản ghi lâm sàng được thu thập từ các bệnh nhân tại nhiều cơ sở y tế, bao gồm đầy
đủ các thông tin về nhân khẩu học, chỉ số sinh lý, thói quen sinh hoạt và tình trạng bệnh tim
mạch (cardiovascular disease – CVD).
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os
# %matplotlib inline

data = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Data Mining/cardio_train.csv')
data

"""Để thực nghiệm phân tích dựa trên chủ đề này, nhóm đã thực hiện việc thu thập *70000* entry về các
ca suy tim từ các bệnh viện công cộng và các yếu tố liên quan tới các ca bệnh trên.
"""

data.info()

data.describe().T

"""**Kiểm tra dữ liệu bị thiếu**"""

data.isnull().sum() / data.shape[0] * 100

"""**Kết luận:** Dữ liệu đầy đủ."""

data.nunique()

"""# **Data Processing**

**1. Delete unnecessary data (eg: id...)**
"""

if 'id' in data.columns:
    data = data.drop(columns=['id'])

data

"""**2. Add age (years) and BMI columns**"""

data['age_years'] = (data['age'] / 365).astype(int)
data['bmi'] = data['weight'] / ((data['height']/100) ** 2)

data

"""**3. Remove outliers using IQR**"""

def remove_outliers_iqr(df, column, factor=1.5):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - factor * IQR
    upper = Q3 + factor * IQR
    return df[(df[column] >= lower) & (df[column] <= upper)]

# Applying IQR for suitable columns (eg: height, weight, bmi,...)
cols_iqr = ['height', 'weight', 'bmi']
for col in cols_iqr:
    data = remove_outliers_iqr(data, col, factor=1.5)   # factor=1.5 is standard

data

"""**4. Combined with hard-threshold for blood pressure**"""

data = data[(data['ap_hi'] > 0) & (data['ap_hi'] <= 200)]
data = data[(data['ap_lo'] > 0) & (data['ap_lo'] <= 150)]
data = data[data['ap_hi'] >= data['ap_lo']]

print(f"Number of rows after processing: {data.shape}  (from 70,000)")
data.describe()

"""# **Exploratory Data Analysis (EDA)**

**1. Overview of cardiovascular variants**
"""

print(data['cardio'].value_counts(normalize=True))
sns.countplot(data=data, x='cardio', palette='Set2')
plt.title('Distribution of heart disease (cardio)')
plt.xlabel('0: No disease | 1: Disease')
plt.show()

"""**Kết quả**:

    50.1% bệnh nhân có bệnh tim (cardio = 1)

    49.9% không bệnh → Cân bằng (balanced) → Không cần xử lý imbalance

Tốt cho mô hình: Accuracy, F1-score sẽ phản ánh đúng.

**2. Correlation between variables**
"""

plt.figure(figsize=(10,8))
corr = data.corr()
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

"""**Top 5 đặc trưng tương quan mạnh nhất với** *cardio*:
1. *age_years* → 0.24
2. *ap_hi* → 0.23
3. *cholesterol* → 0.22
4. *weight / bmi* → ~0.15
5. *ap_lo* → 0.14

Cholesterol và age là 2 yếu tố nguy cơ hàng đầu!

# **Data visualization**

**1. Discrete variables**
"""

# Chọn các biến rời rạc (categorical features)
categorical_cols = ['gender', 'cholesterol', 'gluc', 'smoke', 'alco', 'active']

# Biểu đồ tần suất biến mục tiêu
plt.figure(figsize=(6, 4))
sns.countplot(data=data, x='cardio', hue='cardio', palette='coolwarm', legend=False)
plt.title("Phân bố biến mục tiêu 'cardio'")
plt.xlabel("Giá trị cardio (0 hoặc 1)")
plt.ylabel("Số lượng")
plt.show()

# Tính tỉ lệ của các biến rời rạc so với biến mục tiêu
for col in categorical_cols:
    cross_tab = pd.crosstab(data[col], data['cardio'], normalize='columns') * 100
    print(f"\n--- {col.upper()} ---")
    display(cross_tab.round(2))

    # Vẽ biểu đồ
    cross_tab.plot(kind='bar', figsize=(5, 3), color=['#8dd3c7', '#fb8072'])
    plt.title(f"Tỉ lệ {col} theo tình trạng cardio")
    plt.xlabel(col)
    plt.ylabel("Tỉ lệ (%)")
    plt.legend(title='cardio', labels=['0: Không mắc', '1: Mắc'])
    plt.grid(axis='y', linestyle='--', alpha=0.6)
    plt.show()

"""**2. Continuous variables**"""

import seaborn as sns
import matplotlib.pyplot as plt



data_age = 'age_years'

plt.figure(figsize=(18, 5))

# --- Biểu đồ mật độ (KDE Plot) ---
plt.subplot(1, 3, 1)
sns.kdeplot(
    data=data,
    x=data_age,
    hue='cardio',
    fill=True,
    common_norm=False,
    alpha=0.5
)
plt.title(f'Mật độ phân phối của {data_age} theo nhãn cardio')
plt.xlabel(data_age)
plt.ylabel('Mật độ')

# --- Boxplot ---
plt.subplot(1, 3, 2)
sns.boxplot(
    data=data,
    y=data_age,
    x='cardio',
    hue='cardio',
    palette='Set2',
    legend=False
)
plt.title(f'Boxplot của {data_age} theo nhãn cardio')
plt.xlabel('cardio')
plt.ylabel(data_age)

# --- Histogram ---
plt.subplot(1, 3, 3)
sns.histplot(
    data=data,
    x=data_age,
    hue='cardio',
    kde=True,
    bins=30,
    alpha=0.5
)
plt.title(f'Phân phối của {data_age} theo nhãn cardio')
plt.xlabel(data_age)
plt.ylabel('Tần suất')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt



data_height = 'height'


plt.figure(figsize=(18, 5))

# --- Biểu đồ mật độ (KDE Plot) ---
plt.subplot(1, 3, 1)
sns.kdeplot(
    data=data,
    x=data_height,
    hue='cardio',
    fill=True,
    common_norm=False,
    alpha=0.5
)
plt.title(f'Mật độ phân phối của {data_height} theo nhãn cardio')
plt.xlabel(data_height)
plt.ylabel('Mật độ')

# --- Boxplot ---
plt.subplot(1, 3, 2)
sns.boxplot(
    data=data,
    y=data_height,
    x='cardio',
    hue='cardio',
    palette='Set2',
    legend=False
)
plt.title(f'Boxplot của {data_height} theo nhãn cardio')
plt.xlabel('cardio')
plt.ylabel(data_height)

# --- Histogram ---
plt.subplot(1, 3, 3)
sns.histplot(
    data=data,
    x=data_height,
    hue='cardio',
    kde=True,
    bins=30,
    alpha=0.5
)
plt.title(f'Phân phối của {data_height} theo nhãn cardio')
plt.xlabel(data_height)
plt.ylabel('Tần suất')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt



data_weight = 'weight'


plt.figure(figsize=(18, 5))

# --- Biểu đồ mật độ (KDE Plot) ---
plt.subplot(1, 3, 1)
sns.kdeplot(
    data=data,
    x=data_weight,
    hue='cardio',
    fill=True,
    common_norm=False,
    alpha=0.5
)
plt.title(f'Mật độ phân phối của {data_weight} theo nhãn cardio')
plt.xlabel(data_weight)
plt.ylabel('Mật độ')

# --- Boxplot ---
plt.subplot(1, 3, 2)
sns.boxplot(
    data=data,
    y=data_weight,
    x='cardio',
    hue='cardio',
    palette='Set2',
    legend=False
)
plt.title(f'Boxplot của {data_weight} theo nhãn cardio')
plt.xlabel('cardio')
plt.ylabel(data_weight)

# --- Histogram ---
plt.subplot(1, 3, 3)
sns.histplot(
    data=data,
    x=data_weight,
    hue='cardio',
    kde=True,
    bins=30,
    alpha=0.5
)
plt.title(f'Phân phối của {data_weight} theo nhãn cardio')
plt.xlabel(data_weight)
plt.ylabel('Tần suất')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt



data_ap_hi = 'ap_hi'


plt.figure(figsize=(18, 5))

# --- Biểu đồ mật độ (KDE Plot) ---
plt.subplot(1, 3, 1)
sns.kdeplot(
    data=data,
    x=data_ap_hi,
    hue='cardio',
    fill=True,
    common_norm=False,
    alpha=0.5
)
plt.title(f'Mật độ phân phối của {data_ap_hi} theo nhãn cardio')
plt.xlabel(data_ap_hi)
plt.ylabel('Mật độ')

# --- Boxplot ---
plt.subplot(1, 3, 2)
sns.boxplot(
    data=data,
    y=data_ap_hi,
    x='cardio',
    hue='cardio',
    palette='Set2',
    legend=False
)
plt.title(f'Boxplot của {data_ap_hi} theo nhãn cardio')
plt.xlabel('cardio')
plt.ylabel(data_ap_hi)

# --- Histogram ---
plt.subplot(1, 3, 3)
sns.histplot(
    data=data,
    x=data_ap_hi,
    hue='cardio',
    kde=True,
    bins=30,
    alpha=0.5
)
plt.title(f'Phân phối của {data_ap_hi} theo nhãn cardio')
plt.xlabel(data_ap_hi)
plt.ylabel('Tần suất')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt



data_ap_lo = 'ap_lo'


plt.figure(figsize=(18, 5))

# --- Biểu đồ mật độ (KDE Plot) ---
plt.subplot(1, 3, 1)
sns.kdeplot(
    data=data,
    x=data_ap_lo,
    hue='cardio',
    fill=True,
    common_norm=False,
    alpha=0.5
)
plt.title(f'Mật độ phân phối của {data_ap_lo} theo nhãn cardio')
plt.xlabel(data_ap_lo)
plt.ylabel('Mật độ')

# --- Boxplot ---
plt.subplot(1, 3, 2)
sns.boxplot(
    data=data,
    y=data_ap_lo,
    x='cardio',
    hue='cardio',
    palette='Set2',
    legend=False
)
plt.title(f'Boxplot của {data_ap_lo} theo nhãn cardio')
plt.xlabel('cardio')
plt.ylabel(data_ap_lo)

# --- Histogram ---
plt.subplot(1, 3, 3)
sns.histplot(
    data=data,
    x=data_ap_lo,
    hue='cardio',
    kde=True,
    bins=30,
    alpha=0.5
)
plt.title(f'Phân phối của {data_ap_lo} theo nhãn cardio')
plt.xlabel(data_ap_lo)
plt.ylabel('Tần suất')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt



data_BMI = 'bmi'

plt.figure(figsize=(18, 5))

# --- Biểu đồ mật độ (KDE Plot) ---
plt.subplot(1, 3, 1)
sns.kdeplot(
    data=data,
    x=data_BMI,
    hue='cardio',
    fill=True,
    common_norm=False,
    alpha=0.5
)
plt.title(f'Mật độ phân phối của BMI theo nhãn cardio')
plt.xlabel(data_BMI)
plt.ylabel('Mật độ')

# --- Boxplot ---
plt.subplot(1, 3, 2)
sns.boxplot(
    data=data,
    y=data_BMI,
    x='cardio',
    hue='cardio',
    palette='Set2',
    legend=False
)
plt.title(f'Boxplot của BMI theo nhãn cardio')
plt.xlabel('cardio')
plt.ylabel(data_BMI)

# --- Histogram ---
plt.subplot(1, 3, 3)
sns.histplot(
    data=data,
    x=data_BMI,
    hue='cardio',
    kde=True,
    bins=30,
    alpha=0.5
)
plt.title(f'Phân phối của BMI theo nhãn cardio')
plt.xlabel(data_BMI)
plt.ylabel('Tần suất')

plt.tight_layout()
plt.show()

"""# **Import Bonus Library**"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, roc_auc_score, classification_report, confusion_matrix

"""# **Import Model ML**"""

from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier

"""# **Split data: Train / Test && Standardization**

**1. Split data: Train / Test**

**2. Standardization**
"""

# --- PHẦN 3: Chia dữ liệu & Chuẩn hóa (TỐI ƯU) ---
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Tạo feature matrix và target
X = data.drop('cardio', axis=1)
y = data['cardio']

# Lưu tên cột để dùng sau (vẽ biểu đồ, giải thích)
feature_names = X.columns.tolist()

# Chia dữ liệu (stratify để giữ tỷ lệ lớp)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42, stratify=y
)

# Chuẩn hóa (chỉ áp dụng cho các mô hình cần: Logistic, KNN, SVC)
scaler = StandardScaler()
X_train_s = scaler.fit_transform(X_train)
X_test_s = scaler.transform(X_test)

# Dữ liệu thô (dùng cho Tree-based models: Decision Tree, RF, GB)
X_train_raw = X_train.values
X_test_raw = X_test.values

# In thông tin
print(f"\nTrain: {X_train_s.shape} | Test: {X_test_s.shape}")
print(f"Tỷ lệ bệnh tim (y.mean): {y.mean():.3f} → Dữ liệu cân bằng")
print(f"Features ({len(feature_names)}): {feature_names}")

"""# **Realizing the predictive model**"""

from sklearn.metrics import accuracy_score, roc_auc_score, classification_report, confusion_matrix
import pandas as pd

def evaluate_model(model, X_train, X_test, y_train, y_test, scaler=None, model_name=None):
    if model_name is None:
        model_name = model.__class__.__name__.replace("Classifier", "")

    # Chuẩn hóa nếu cần
    if scaler:
        X_train_s = scaler.fit_transform(X_train)
        X_test_s = scaler.transform(X_test)
    else:
        X_train_s, X_test_s = X_train.values, X_test.values

    # Huấn luyện & dự đoán
    model.fit(X_train_s, y_train)
    y_pred = model.predict(X_test_s)
    y_prob = model.predict_proba(X_test_s)[:, 1]

    # Tính toán
    acc = accuracy_score(y_test, y_pred)
    auc = roc_auc_score(y_test, y_prob)

    # In kết quả
    print("="*60)
    print(f"{model_name.upper()}".center(60))
    print("="*60)
    print(f"{model_name} Accuracy: {acc*100:.2f}%")
    print(classification_report(y_test, y_pred, digits=2))
    print("Confusion Matrix:")
    print(confusion_matrix(y_test, y_pred))
    print(f"ROC AUC Score: {auc:.12f}\n")

    return model

results = []
def save_result(model, X_test_input, name):
    from sklearn.metrics import accuracy_score, roc_auc_score, f1_score
    y_pred = model.predict(X_test_input)
    y_prob = model.predict_proba(X_test_input)[:, 1]
    results.append({
        "Model": name,
        "Accuracy": round(accuracy_score(y_test, y_pred), 4),
        "ROC-AUC": round(roc_auc_score(y_test, y_prob), 4),
        "F1": round(f1_score(y_test, y_pred), 4)
    })

"""**Logistic Regression**"""

from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

model = LogisticRegression(max_iter=1000, random_state=42)
trained_model = evaluate_model(
    model, X_train, X_test, y_train, y_test,
    scaler=StandardScaler(), model_name="Logistic Regression"
)

# Vẽ Top 10 hệ số
plt.figure(figsize=(8,5))
coef = pd.Series(trained_model.coef_[0], index=X.columns).abs().sort_values(ascending=False).head(10)
sns.barplot(x=coef.values, y=coef.index, palette='viridis')
plt.title("Logistic Regression – Top 10 Risk Factors")
plt.xlabel("Absolute Coefficient")
plt.tight_layout()
plt.show()
save_result(trained_model, X_test_s, "Logistic")

"""**Decision Tree**"""

from sklearn.tree import DecisionTreeClassifier
import matplotlib.pyplot as plt

model = DecisionTreeClassifier(max_depth=5, random_state=42)
trained_model = evaluate_model(
    model, X_train, X_test, y_train, y_test,
    scaler=None, model_name="Decision Tree"
)

# Vẽ cây (3 cấp)
plt.figure(figsize=(16,8))
from sklearn.tree import plot_tree
plot_tree(trained_model, max_depth=3, feature_names=X.columns,
          class_names=['No Disease','Disease'], filled=True, fontsize=10, proportion=True)
plt.title("Decision Tree – First 3 Levels")
plt.show()
save_result(trained_model, X_test_raw, "Tree")

"""**Random Forest**"""

from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

model = RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1)
trained_model = evaluate_model(
    model, X_train, X_test, y_train, y_test,
    scaler=None, model_name="Random Forest"
)

# Vẽ Top 10 Feature Importance
plt.figure(figsize=(8,5))
imp = pd.Series(trained_model.feature_importances_, index=X.columns).sort_values(ascending=True).tail(10)
sns.barplot(x=imp.values, y=imp.index, palette='magma')
plt.title("Random Forest – Top 10 Feature Importance")
plt.xlabel("Importance")
plt.tight_layout()
plt.show()
save_result(trained_model, X_test_raw, "RF")

"""**Gradient Boosting**"""

from sklearn.ensemble import GradientBoostingClassifier
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

model = GradientBoostingClassifier(n_estimators=100, random_state=42)
trained_model = evaluate_model(
    model, X_train, X_test, y_train, y_test,
    scaler=None, model_name="Gradient Boosting"
)

# Vẽ Top 10 Feature Importance
plt.figure(figsize=(8,5))
imp = pd.Series(trained_model.feature_importances_, index=X.columns).sort_values(ascending=True).tail(10)
sns.barplot(x=imp.values, y=imp.index, palette='plasma')
plt.title("Gradient Boosting – Top 10 Feature Importance")
plt.xlabel("Importance")
plt.tight_layout()
plt.show()
save_result(trained_model, X_test_raw, "GB")

"""**K-Neighbors Classifier**"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import f1_score
import matplotlib.pyplot as plt
import numpy as np

model = KNeighborsClassifier(n_neighbors=7)
trained_model = evaluate_model(
    model, X_train, X_test, y_train, y_test,
    scaler=StandardScaler(), model_name="KNN"
)

# Vẽ F1-score vs k
k_range = range(1, 21)
f1s = [
    f1_score(y_test, KNeighborsClassifier(n_neighbors=k)
             .fit(StandardScaler().fit_transform(X_train), y_train)
             .predict(StandardScaler().fit_transform(X_test)))
    for k in k_range
]

plt.figure(figsize=(8,5))
plt.plot(k_range, f1s, marker='o', color='teal')
best_k = k_range[np.argmax(f1s)]
plt.axvline(best_k, color='red', linestyle='--', label=f'Best k = {best_k}')
plt.title("KNN – F1-Score vs k")
plt.xlabel("k"); plt.ylabel("F1-Score")
plt.legend(); plt.grid(True, alpha=0.3)
plt.tight_layout(); plt.show()
save_result(trained_model, X_test_s, "KNN")

"""**Support Vector Classifier - SVC**"""

from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import roc_curve
import matplotlib.pyplot as plt

# Dùng 20% dữ liệu để tránh treo
X_train_svc, _, y_train_svc, _ = train_test_split(
    X_train, y_train, train_size=0.2, stratify=y_train, random_state=42
)

model = SVC(probability=True, kernel='rbf', C=1.0, gamma='scale', random_state=42)
trained_model = evaluate_model(
    model, X_train_svc, X_test, y_train_svc, y_test,
    scaler=StandardScaler(), model_name="SVC"
)

# Vẽ ROC Curve
X_test_s = StandardScaler().fit_transform(X_test)
y_prob = trained_model.predict_proba(X_test_s)[:, 1]
fpr, tpr, _ = roc_curve(y_test, y_prob)

plt.figure(figsize=(7,5))
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'AUC = {roc_auc_score(y_test, y_prob):.3f}')
plt.plot([0,1],[0,1], 'k--')
plt.xlim([0,1]); plt.ylim([0,1.05])
plt.xlabel('False Positive Rate'); plt.ylabel('True Positive Rate')
plt.title('SVC – ROC Curve'); plt.legend(loc='lower right')
plt.grid(True, alpha=0.3); plt.tight_layout(); plt.show()
save_result(trained_model, X_test_s, "SVC")

"""**Model evaluation**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.DataFrame(results).sort_values("ROC-AUC", ascending=False)
print(df.to_string(index=False))

plt.figure(figsize=(9,5))
df_melt = df.melt('Model', var_name='Metric', value_name='Score')
sns.barplot(data=df_melt, x='Score', y='Model', hue='Metric', palette='Set2')
plt.title("So sánh các mô hình")
plt.xlim(0.65, 1.0)
plt.legend(title='Chỉ số')
plt.tight_layout()
plt.show()